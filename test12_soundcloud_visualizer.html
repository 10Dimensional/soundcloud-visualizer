<!DOCTYPE html>
<html>
<head>
<title></title>
<script>

/**
 * The AudioSource object creates an analyzer node, sets up a repeating function with setInterval
 * which samples the input and turns it into an FFT array. The object has two properties:
 * streamData - this is the Uint8Array containing the FFT data
 * volume - cumulative value of all the bins of the streaData.
 */
var AudioSource = function() {
    var self = this;
    this.volume = 0;
    this.streamData = new Uint8Array(128);
    var analyser;

    var sampleAudioStream = function() {
        analyser.getByteFrequencyData(self.streamData);
        // calculate an overall volume value
        var total = 0;
        for(var i in self.streamData) {
            total += self.streamData[i];
        }
        self.volume = total;
    };

    // get the input stream from the microphone
    navigator.getMedia = (
            navigator.getUserMedia ||
                    navigator.webkitGetUserMedia ||
                    navigator.mozGetUserMedia ||
                    navigator.msGetUserMedia
            );
    navigator.getMedia ( { audio: true }, function (stream) {
        var audioCtx = new (window.AudioContext || window.webkitAudioContext);
        var mic = audioCtx.createMediaStreamSource(stream);
        analyser = audioCtx.createAnalyser();
        analyser.fftSize = 256;
        mic.connect(analyser);
        setInterval(sampleAudioStream, 20);
    }, function(){ alert("error getting microphone input."); });
};

/**
 * The Visualizer object, after being instantiated, must be initialized with the init() method,
 * which takes an options object specifying the canvases to work on and the audiosource which will
 * provide the data to be visualized.
 */
var Visualizer = function() {
    var tileSize;
    var tiles = [];
    var stars = [];
    // canvas vars
    var fgCanvas;
    var fgCtx;
    var fgRotation = 0.001;
    var bgCanvas;
    var bgCtx;
    var bgRotation = 0;
    var sfCanvas;
    var sfCtx;
    var audioSource;
    var bgImg = new Image();

    function Polygon(sides, x, y, tileSize, ctx, num) {
        this.sides = sides;
        this.tileSize = tileSize;
        this.ctx = ctx;
        this.num = num; // the number of the tile, starting at 0
        this.high = 0; // the highest colour value, which then fades out
        this.decay = this.num > 65 ? 0.1 : 2 // increase this value to fade out faster.
        this.highlight = 0; // for highlighted stroke effect;
        // figure out the x and y coordinates of the center of the polygon based on the
        // 60 degree XY axis coordinates passed in
        var step = Math.round(Math.cos(Math.PI/6)*tileSize*2);
        this.y = Math.round(step * Math.sin(Math.PI/3) * -y  );
        this.x = Math.round(x * step + y * step/2 );

        // calculate the vertices of the polygon
        this.vertices = [];
        for (var i = 1; i <= this.sides;i += 1) {
            x = this.x + this.tileSize * Math.cos(i * 2 * Math.PI / this.sides + Math.PI/6);
            y = this.y + this.tileSize * Math.sin(i * 2 * Math.PI / this.sides + Math.PI/6);
            this.vertices.push([x, y]);
        }
    }
    Polygon.prototype.rotateVertices = function() {
        // rotate all the vertices to achieve the overall rotational effect
        for (var i = 0; i <= this.sides-1;i += 1) {
            this.vertices[i][0] = this.vertices[i][0] -  this.vertices[i][1] * Math.sin(fgRotation);
            this.vertices[i][1] = this.vertices[i][1] +  this.vertices[i][0] * Math.sin(fgRotation);
        }
    }
    Polygon.prototype.calculateOffset = function(coords) {
        var angle = Math.atan(coords[1]/coords[0]);
        var distance = Math.sqrt(Math.pow(coords[0], 2) + Math.pow(coords[1], 2)); // a bit of pythagoras
        var offsetFactor = Math.pow(distance/3, 2) * audioSource.volume/3000000 * Math.pow(this.high, 1.3)/300;
        var offsetX = Math.cos(angle) * offsetFactor;
        var offsetY = Math.sin(angle) * offsetFactor;
        offsetX *= (coords[0] < 0) ? -1 : 1;
        offsetY *= (coords[0] < 0) ? -1 : 1;
        return [offsetX, offsetY];
    }
    Polygon.prototype.drawPolygon = function() {
        var bucket = Math.ceil(audioSource.streamData.length/tiles.length*this.num);
        var val = Math.pow((audioSource.streamData[bucket]/255),2)*255;

        // establish the value for this tile
        if (val > this.high) {
            this.high = val;
        } else {
            this.high -= this.decay;
            val = this.high;
        }

        // figure out what colour to fill it and then draw the polygon
        var r, g, b, a;
        if (val > 0) {
            this.ctx.beginPath();
            var offset = this.calculateOffset(this.vertices[0]);
            this.ctx.moveTo(this.vertices[0][0] + offset[0], this.vertices[0][1] + offset[1]);
            // draw the polygon
            for (var i = 1; i <= this.sides-1;i += 1) {
                offset = this.calculateOffset(this.vertices[i]);
                this.ctx.lineTo (this.vertices[i][0] + offset[0], this.vertices[i][1] + offset[1]);
            }
            this.ctx.closePath();

           if (val > 128) {
                r = (val-128)*2;
                g = Math.round((Math.cos((2*val/128*Math.PI/2)- 4*Math.PI/3)+1)*128);
                b = (val-105)*3;
            }
            else if (val > 175) {
                r = (val-128)*2;
                g = 255;
                b = (val-105)*3;
            }
            else {
                r = Math.round((Math.cos((2*val/128*Math.PI/2))+1)*128);
                g = Math.round((Math.cos((2*val/128*Math.PI/2)- 4*Math.PI/3)+1)*128);
                b = Math.round((Math.cos((2.4*val/128*Math.PI/2)- 2*Math.PI/3)+1)*128);
            }
            if (val > 210) {
                this.cubed = val; // add the cube effect if it's really loud
            }
            if (val > 120) {
                this.highlight = 100; // add the highlight effect if it's pretty loud
            }
            // set the alpha
            var e = 2.7182;
            a = (0.5/(1 + 40 * Math.pow(e, -val/8))) + (0.5/(1 + 40 * Math.pow(e, -val/20)));

            this.ctx.fillStyle = "rgba(" + r + ", " + g + ", " + b + ", " + a + ")";
            this.ctx.fill();
            // stroke
            if (val > 20) {
                var strokeVal = 20;
                this.ctx.strokeStyle =  "rgba(" + strokeVal + ", " + strokeVal + ", " + strokeVal + ", 0.5)";
                this.ctx.lineWidth = 1;
                this.ctx.stroke();
            }
        }
    };
    Polygon.prototype.drawHighlight = function() {
        this.ctx.beginPath();
        // draw the highlight
        var offset = this.calculateOffset(this.vertices[0]);
        this.ctx.moveTo(this.vertices[0][0] + offset[0], this.vertices[0][1] + offset[1]);
        // draw the polygon
        for (var i = 0; i <= this.sides-1;i += 1) {
            offset = this.calculateOffset(this.vertices[i]);
            this.ctx.lineTo (this.vertices[i][0] + offset[0], this.vertices[i][1] + offset[1]);
        }
        this.ctx.closePath();
        var a = this.highlight/100;
        this.ctx.strokeStyle =  "rgba(255, 255, 255, " + a + ")";
        this.ctx.lineWidth = 1;
        this.ctx.stroke();
        this.highlight -= 0.5;
    };

    var makePolygonArray = function() {
        tiles = [];
        /**
         * Arrange into a grid x, y, with the y axis at 60 degrees to the x, rather than
         * the usual 90.
         * @type {number}
         */
        var i = 0; // unique number for each tile
        tiles.push(new Polygon(6, 0, 0, tileSize, fgCtx, i)); // the centre tile
        i++;
        for (var layer = 1; layer < 7; layer++) {
            tiles.push(new Polygon(6, 0, layer, tileSize, fgCtx, i)); i++;
            tiles.push(new Polygon(6, 0, -layer, tileSize, fgCtx, i)); i++;
            for(var x = 1; x < layer; x++) {
                tiles.push(new Polygon(6, x, -layer, tileSize, fgCtx, i)); i++;
                tiles.push(new Polygon(6, -x, layer, tileSize, fgCtx, i)); i++;
                tiles.push(new Polygon(6, x, layer-x, tileSize, fgCtx, i)); i++;
                tiles.push(new Polygon(6, -x, -layer+x, tileSize, fgCtx, i)); i++;
            }
            for(var y = -layer; y <= 0; y++) {
                tiles.push(new Polygon(6, layer, y, tileSize, fgCtx, i)); i++;
                tiles.push(new Polygon(6, -layer, -y, tileSize, fgCtx, i)); i++;
            }
        }
    };

    function Star(x, y, starSize, ctx) {
        this.x = x;
        this.y = y;
        this.angle = Math.atan(Math.abs(y)/Math.abs(x));
        this.starSize = starSize;
        this.ctx = ctx;
        this.high = 0;
        this.decay = 0.2 + Math.random() * 0.8;
    }
    Star.prototype.drawStar = function() {
        var vol = Math.pow(Math.ceil(audioSource.volume/4500),1.5);
        var radius = (this.starSize*2) * vol * Math.random();
        if (radius > this.high) {
            this.high = radius;
        } else {
            radius = this.high;
            if (this.high > 1) {
                this.high -= 0.5 * this.decay;
            }
        }

        var brightness = 150 + Math.round(radius * 5);
        var a = this.starSize/5;

        var radgrad = this.ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, radius);
        radgrad.addColorStop(0, 'rgba(' + brightness + ', ' + brightness + ', ' + brightness + ', ' + a + ')');
        radgrad.addColorStop(0.5, 'rgba(' + brightness + ', ' + brightness + ', ' + brightness + ', ' + a/2 + ')');
        radgrad.addColorStop(1, 'rgba(' + brightness + ', ' + brightness + ', ' + brightness + ', 0)');

        // draw shape
        this.ctx.fillStyle = radgrad;
        //this.ctx.fillStyle = "white";
        this.ctx.fillRect(this.x-radius*Math.PI/2,this.y-radius*Math.PI/2, radius*Math.PI, radius*Math.PI);

        // starfield movement coming towards the camera
        var dX = Math.cos(this.angle) * this.starSize/50;
        var dY = Math.sin(this.angle) * this.starSize/50;
        this.x += this.x > 0 ? dX : -dX;
        this.y += this.y > 0 ? dY : -dY;

        if ((this.y > fgCanvas.height/2 || this.y < -fgCanvas.height/2) || (this.x > fgCanvas.width/2 || this.x < -fgCanvas.width/2)) {
            // it has gone off the edge so respawn it somewhere near the middle.
            this.x = (Math.random() - 0.5) * fgCanvas.width/3;
            this.y = (Math.random() - 0.5) * fgCanvas.height/3;
            this.angle = Math.atan(Math.abs(this.y)/Math.abs(this.x));
        }
        this.ctx.font = "bold 12px sans-serif";
        this.ctx.fillStyle = 'grey';
    };

    var makeStarArray = function() {
        var x, y, starSize;
        stars = [];
        var limit = fgCanvas.width / 15; // how many stars?
        for (var i = 0; i < limit; i ++) {
            x = (Math.random() - 0.5) * fgCanvas.width;
            y = (Math.random() - 0.5) * fgCanvas.height;
            starSize = (Math.random()+0.1)*5;
            stars.push(new Star(x, y, starSize, sfCtx));
        }
    };

    var drawBg = function() {
        bgCtx.clearRect(0,0,fgCanvas.width,fgCanvas.height);
        // save the unrotated context of the canvas so we can restore it later
        // the alternative is to untranslate & unrotate after drawing
        bgCtx.save();
        // move to the center of the canvas
        bgCtx.translate(fgCanvas.width/2,fgCanvas.height/2);
        // rotate the canvas to the specified degrees
        bgCtx.rotate(bgRotation*Math.PI/180);
        // draw the image
        // since the context is rotated, the image will be rotated also
        bgCtx.drawImage(bgImg, -bgImg.width/2,-bgImg.height/2);
        // we’re done with the rotating so restore the unrotated context
        bgCtx.restore();
        bgRotation += 0.03;
    };

    var resizeCanvas = function() {
        if (fgCanvas) {
            // resize the foreground canvas
            fgCanvas.width = window.innerWidth;
            fgCanvas.height = window.innerHeight;
            fgCtx.translate(fgCanvas.width/2,fgCanvas.height/2);
            tileSize = fgCanvas.width / 25;
            // resize the bg canvas
            bgCanvas.width = window.innerWidth;
            bgCanvas.height = window.innerHeight;
            // resize the starfield canvas
            sfCanvas.width = window.innerWidth;
            sfCanvas.height = window.innerHeight;
            sfCtx.translate(fgCanvas.width/2,fgCanvas.height/2);

            drawBg();
            makePolygonArray();
            makeStarArray()
        }
    };

    rotateForeground = function() {
        tiles.forEach(function(tile) {
            tile.rotateVertices();
        });
    };

    var draw = function() {
            fgCtx.clearRect(-fgCanvas.width, -fgCanvas.height, fgCanvas.width*2, fgCanvas.height *2);
            sfCtx.clearRect(-fgCanvas.width/2, -fgCanvas.height/2, fgCanvas.width, fgCanvas.height);

            stars.forEach(function(star) {
                star.drawStar();
            });
            tiles.forEach(function(tile) {
                tile.drawPolygon();
            });
            tiles.forEach(function(tile) {
                if (tile.highlight > 0) {
                    tile.drawHighlight();
                }
            });
            requestAnimationFrame(draw);
        };

    this.init = function(options) {
        audioSource = options.audioSource;
        var container = document.getElementById(options.containerId);

        // foreground hexagons layer
        fgCanvas = document.createElement('canvas');
        fgCanvas.setAttribute('style', 'position: absolute; z-index: 10');
        fgCtx = fgCanvas.getContext("2d");
        container.appendChild(fgCanvas);

        // middle starfield layer
        sfCanvas = document.createElement('canvas');
        sfCtx = sfCanvas.getContext("2d");
        sfCanvas.setAttribute('style', 'position: absolute; z-index: 5');
        container.appendChild(sfCanvas);

        // background image layer
        bgCanvas = document.createElement('canvas');
        bgCtx = bgCanvas.getContext("2d");
        container.appendChild(bgCanvas);
        bgImg.onload = function() {
            bgCtx.drawImage(bgImg, 0, 0);
        };
        bgImg.src = options.bgImage;;

        tileSize = fgCanvas.width / 25;

        makePolygonArray();
        makeStarArray();
        draw();


        setInterval(drawBg, 100);
        setInterval(rotateForeground, 50);
        // resize the canvas to fill browser window dynamically
        window.addEventListener('resize', resizeCanvas, false);
    };
};

window.onload = function() {
    var visualizer = new Visualizer();
    visualizer.init(
            {
                containerId: 'visulaizer',
                audioSource: new AudioSource(),
                bgImage: 'spacebg.jpg'
            }
    );
};
</script>
<style type="text/css">
    * {
        padding: 0;
        margin: 0;
    }
    body {
        background-color: #000000;
    }
    #canvas {
        display: block;
        position: absolute;
        top: 0;
        left: 0;
        z-index: 10;
    }
    #bg {
        display: block;
        position: absolute;
        top: 0;
        left: 0;
        z-index: 1;
    }
    #starfield {
        display: block;
        position: absolute;
        top: 0;
        left: 0;
        z-index: 5;
    }
</style>
</head>
<body>
<div id="visulaizer"></div>
</body>
</html>